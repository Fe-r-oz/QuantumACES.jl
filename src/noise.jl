"""
    DepolarisingParameters

Parameterises a depolarising Pauli noise model.

# Fields

  - `r_1::Float64`: Single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.
  - `r_2::Float64`: Two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.
  - `r_m::Float64`: Measurement entanglement infidelity, the measurement error probability.
  - `noise_name::String`: Noise parameter name for saving data.
"""
struct DepolarisingParameters <: AbstractNoiseParameters
    r_1::Float64
    r_2::Float64
    r_m::Float64
    noise_name::String
    # Constructor
    function DepolarisingParameters(
        r_1::Float64,
        r_2::Float64,
        r_m::Float64,
        noise_name::String,
    )
        # Check some conditions
        @assert (r_1 >= 0) && (r_1 <= 3 / 4) "The single-qubit gate entanglement infidelity $(r_1) is out of bounds."
        @assert (r_2 >= 0) && (r_2 <= 15 / 16) "The two-qubit gate entanglement infidelity $(r_2) is out of bounds."
        @assert (r_m >= 0) && (r_m <= 1 / 2) "The measurement entanglement infidelity $(r_m) is out of bounds."
        test_noise_name = "depolarising_$(round(r_1; sigdigits = 4))_$(round(r_2; sigdigits = 4))_$(round(r_m; sigdigits = 4))"
        @assert noise_name == test_noise_name "The noise name $(noise_name) does not match the noise name generated by the supplied parameters $(test_noise_name)."
        # Return parameters
        return new(r_1, r_2, r_m, noise_name)::DepolarisingParameters
    end
end

@struct_hash_equal_isequal DepolarisingParameters

"""
    get_dep_param(r_1::Float64, r_2::Float64, r_m::Float64)

Return a [`DepolarisingParameters`](@ref) object that parameterises a depolarising Pauli noise model with single-qubit, two-qubit, and measurement infidelities `r_1`, `r_2`, and `r_m`, respectively.
"""
function get_dep_param(r_1::Float64, r_2::Float64, r_m::Float64)
    # Set the noise name
    noise_name = "depolarising_$(round(r_1; sigdigits = 4))_$(round(r_2; sigdigits = 4))_$(round(r_m; sigdigits = 4))"
    dep_param = DepolarisingParameters(r_1, r_2, r_m, noise_name)
    return dep_param::DepolarisingParameters
end

"""
    LognormalParameters

Parameterises a log-normally random Pauli noise model.

# Fields

  - `r_1::Float64`: Average single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.
  - `r_2::Float64`: Average two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.
  - `r_m::Float64`: Average measurement entanglement infidelity, the measurement error probability.
  - `total_std_log::Float64`: Approximate standard deviation of the logarithm of the entanglement infidelity across all gate types.
  - `seed::UInt64`: Random seed used to generate the noise.
  - `noise_name::String`: Noise parameter name for saving data.
"""
struct LognormalParameters <: AbstractNoiseParameters
    r_1::Float64
    r_2::Float64
    r_m::Float64
    total_std_log::Float64
    seed::UInt64
    noise_name::String
    # Default constructor
    function LognormalParameters(
        r_1::Float64,
        r_2::Float64,
        r_m::Float64,
        total_std_log::Float64,
        seed::UInt64,
        noise_name::String,
    )
        # Check some conditions
        @assert (r_1 >= 0) && (r_1 <= 3 / 4) "The single-qubit gate entanglement infidelity $(r_1) is out of bounds."
        @assert (r_2 >= 0) && (r_2 <= 15 / 16) "The two-qubit gate entanglement infidelity $(r_2) is out of bounds."
        @assert (r_m >= 0) && (r_m <= 1 / 2) "The measurement entanglement infidelity $(r_m) is out of bounds."
        test_noise_name = "lognormal_$(round(r_1; sigdigits = 4))_$(round(r_2; sigdigits = 4))_$(round(r_m; sigdigits = 4))_$(round(total_std_log; sigdigits = 4))_$(seed)"
        @assert noise_name == test_noise_name "The noise name $(noise_name) does not match the noise name generated by the supplied parameters $(test_noise_name)."
        # Return parameters
        return new(r_1, r_2, r_m, total_std_log, seed, noise_name)::LognormalParameters
    end
end

@struct_hash_equal_isequal LognormalParameters

"""
    get_log_param(r_1::Float64, r_2::Float64, r_m::Float64, total_std_log::Float64; seed::Union{UInt64, Nothing} = nothing)

Return a [`LognormalParameters`](@ref) object that parameterises a log-normally random Pauli noise model with average single-qubit, two-qubit, and measurement infidelities `r_1`, `r_2`, and `r_m`, respectively, approximate standard deviation of the logarithm of the entanglement infidelity `total_std_log`, and random seed `seed`, which is randomly generated if not supplied.
"""
function get_log_param(
    r_1::Float64,
    r_2::Float64,
    r_m::Float64,
    total_std_log::Float64;
    seed::Union{UInt64, Nothing} = nothing,
)
    # Set the noise name and random seed, if one isn't supplied
    if seed === nothing
        seed = rand(UInt64)
    end
    noise_name = "lognormal_$(round(r_1; sigdigits = 4))_$(round(r_2; sigdigits = 4))_$(round(r_m; sigdigits = 4))_$(round(total_std_log; sigdigits = 4))_$(seed)"
    # Return parameters
    log_param = LognormalParameters(r_1, r_2, r_m, total_std_log, seed, noise_name)
    return log_param::LognormalParameters
end

"""
    get_gate_probabilities(total_gates::Vector{Gate}, noise_param::DepolarisingParameters)
    get_gate_probabilities(total_gates::Vector{Gate}, noise_param::LognormalParameters)

Returns a dictionary of the Pauli error probabilities for each gate in `total_gates` generated according to the noise parameters `noise_param`.

For single-qubit gates, the Pauli error probabilities are ordered as `I`, `X`, `Z`, `Y`.
For two-qubit gates, the Pauli error probabilities are ordered as `II`, `XI`, `IX`, `XX`, `ZI`, `YI`, `ZX`, `YX`, `IZ`, `XZ`, `IY`, `XY`, `ZZ`, `YZ`, `ZY`, `YY`.
"""
function get_gate_probabilities(
    total_gates::Vector{Gate},
    noise_param::DepolarisingParameters,
)
    # Extract the parameters for generating the noise
    p_1 = noise_param.r_1 / 3
    p_2 = noise_param.r_2 / 15
    p_m = noise_param.r_m
    # Generate the noise
    gate_probabilities = Dict{Gate, Vector{Float64}}()
    for gate in total_gates
        if gate.type ∈ ["MZ", "MX", "MY"]
            probability = [p_m]
        elseif length(gate.targets) == 1
            probability = p_1 * ones(3)
        elseif length(gate.targets) == 2
            probability = p_2 * ones(15)
        else
            throw(error("The gate $(gate) is unsupported."))
        end
        @assert sum(probability) < 1 "The probabilities $(probability) sum to more than 1; change the input parameters."
        gate_probabilities[gate] = [1 - sum(probability); probability]
    end
    return gate_probabilities::Dict{Gate, Vector{Float64}}
end
function get_gate_probabilities(total_gates::Vector{Gate}, noise_param::LognormalParameters)
    # Extract the parameters for generating the noise
    r_1 = noise_param.r_1
    r_2 = noise_param.r_2
    r_m = noise_param.r_m
    total_std_log = noise_param.total_std_log
    seed = noise_param.seed
    # We approximate the sum of log-normal random variables as a log-normal random variable # with the same mean and standard deviation, in order to ensure that the sum has a mean
    # that is approximately independent of the standard deviation, total_std_log
    p_1_std_log = sqrt(log(1 + 3 * (exp(total_std_log^2) - 1)))
    p_2_std_log = sqrt(log(1 + 15 * (exp(total_std_log^2) - 1)))
    p_m_std_log = total_std_log
    p_1_mean_log = log(r_1 / 3) - p_1_std_log^2 / 2
    p_2_mean_log = log(r_2 / 15) - p_2_std_log^2 / 2
    p_m_mean_log = log(r_m) - p_m_std_log^2 / 2
    # Fix the random seed
    Random.seed!(seed)
    # Generate the noise
    gate_probabilities = Dict{Gate, Vector{Float64}}()
    for gate in total_gates
        if gate.type ∈ ["MZ", "MX", "MY"]
            probability = [exp(p_m_std_log * randn() + p_m_mean_log)]
        elseif length(gate.targets) == 1
            probability = exp.(p_1_std_log * randn(3) .+ p_1_mean_log)
        elseif length(gate.targets) == 2
            probability = exp.(p_2_std_log * randn(15) .+ p_2_mean_log)
        else
            throw(error("The gate $(gate) is unsupported."))
        end
        @assert sum(probability) < 1 "The probabilities $(probability) sum to more than 1; change the input parameters."
        gate_probabilities[gate] = [1 - sum(probability); probability]
    end
    # Reset the random seed
    Random.seed!()
    return gate_probabilities::Dict{Gate, Vector{Float64}}
end

"""
    get_gate_eigenvalues(gate_probabilities::Dict{Gate, Vector{Float64}}, total_gates::Vector{Gate}, gate_index::Dict{Gate, Int}, N::Int)

Returns the eigenvalues corresponding to the supplied Pauli error probabilities `gate_probabilities`, ordered by the gates into a vector for the gates `total_gates` using the index data `gate_index` and `N` produced by [`index_gates`](@ref).
"""
function get_gate_eigenvalues(
    gate_probabilities::Dict{Gate, Vector{Float64}},
    total_gates::Vector{Gate},
    gate_index::Dict{Gate, Int},
    N::Int,
)
    # Generate the Walsh-Hadamard transform matrices
    W_1 = wht_matrix(1)
    W_2 = wht_matrix(2)
    # Generate the gate eigenvalues
    gate_eigenvalues = Vector{Float64}(undef, N)
    for gate in total_gates
        if gate.type ∈ ["MZ", "MX", "MY"]
            gate_eig = 1 - 2 * gate_probabilities[gate][2]
            gate_eigenvalues[gate_index[gate] + 1] = gate_eig
        else
            if length(gate.targets) == 1
                gate_eig = W_1 * gate_probabilities[gate]
            elseif length(gate.targets) == 2
                gate_eig = W_2 * gate_probabilities[gate]
            else
                throw(error("Unsupported gate $(gate)."))
            end
            gate_eigenvalues[(gate_index[gate] + 1):(gate_index[gate] + (4^length(
                gate.targets,
            ) - 1))] = gate_eig[2:end]
        end
    end
    return gate_eigenvalues::Vector{Float64}
end
