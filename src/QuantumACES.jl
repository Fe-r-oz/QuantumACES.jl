"""
`QuantumACES.jl` is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES).
It is particularly interested in characterising the noise associated with fault-tolerant gadgets in the context of topological quantum error correcting codes, such as surface code syndrome extraction circuits.
"""
module QuantumACES

# Imports
using PythonCall,
    Base.Threads,
    LinearAlgebra,
    SparseArrays,
    Random,
    Distributions,
    Combinatorics,
    StatsBase,
    GLM,
    LsqFit,
    QuadGK,
    FiniteDifferences,
    DataFrames,
    Accessors,
    StructEquality,
    PrettyTables,
    FileIO,
    JLD2

# Abstract types
"""
    AbstractNoiseParameters

Noise parameters should be stored in a subtype `T <: AbstractNoiseParameters`.

Noise models should be generated by a method of [`get_gate_probabilities`](@ref), which generates Pauli error probabilities for the supplied gates according to some supplied noise parameters.

# Necessary fields

  - `noise_name::String`: Name of the noise model, which should implicitly describe parameter settings.
"""
abstract type AbstractNoiseParameters end

"""
    AbstractCircuitParameters

Circuit parameters should be stored in a subtype `T <: AbstractCircuitParameters`.

Then add a method to [`get_circuit`](@ref) that generates a circuit according to these parameters.
Such a circuit should either be a [`Circuit`](@ref) type, or a subtype `T <: AbstractCircuit`.

# Necessary fields

  - `layer_time_dict::Dict{Symbol, Float64}`: Dictionary of the times taken to implement the different types of layers in the circuit, including the time for measurement and reset.
  - `circuit_name::String`: Name of the circuit, which should implicitly describe parameter settings.
"""
abstract type AbstractCircuitParameters end

"""
    AbstractCircuit

Circuits should be stored in a subtype `T <: AbstractCircuit`.

Circuits should be generated by a method of [`get_circuit`](@ref), and [`prepare_circuit`](@ref) is a helpful function for writing such a method.

# Necessary fields

  - `circuit_param::AbstractCircuitParameters`: Circuit parameters.
  - `circuit::Vector{Layer}`: Circuit arranged by the tuple.
  - `circuit_tuple::Vector{Int}`: Tuple which arranges the order of the circuit layers; this is initialised as trivial.
  - `qubit_num::Int`: Number of qubits in the circuit.
  - `unique_layer_indices::Vector{Int}`: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.
  - `layer_types::Vector{Symbol}`: Types of the layers in the circuit, used for layer times and dynamical decoupling.
  - `layer_times::Vector{Float64}`: Times taken to implement each layer in the circuit, as well as measurement and reset.
  - `gates::Vector{Gate}`: Gates in the circuit arranged by the tuple.
  - `total_gates::Vector{Gate}`: Gates in the original circuit, which includes noisy preparations if `add_prep` and noisy measurements if `add_meas`.
  - `gate_index::Dict{Gate, Int}`: Index of the gate eigenvalues for each gates in the original circuit.
  - `N::Int`: Number of gate eigenvalues.
  - `noise_param::AbstractNoiseParameters`: Noise parameters.
  - `gate_probabilities::Dict{Gate, Vector{Float64}}`: Pauli error probabilities for each gate, stored as a dictionary.
  - `gate_eigenvalues::Vector{Float64}`: Eigenvalues for each gate, stored as a vector whose order is determined by `gate_index`.
  - `add_prep::Bool`: Whether to treat preparations as noisy and characterise the associated noise, which should default to `false`; a full-rank design cannot be produced if both `add_prep` and `add_meas` are `true`.
  - `add_meas::Bool`: Whether to treat measurements as noisy and characterise the associated noise, which should default to `true`; a full-rank design cannot be produced if both `add_prep` and `add_meas` are `true`.

# Optional fields

  - `partition::Tuple{Vector{Int}, Vector{Int}}`: A partition of the qubits into two sets such that two-qubit gates act only between the sets, which allows for easy preparation of sign configurations for Pauli eigenstates; for example, data and ancilla qubits for a syndrome extraction circuit.
"""
abstract type AbstractCircuit end

"""
    AbstractScalingData

Scaling data for the figure of merit should be stored in a subtype `T <: AbstractScalingData`.

# Necessary fields

  - `circuit_param::AbstractCircuitParameters`: Circuit parameters.
  - `noise_param::AbstractNoiseParameters`: Noise parameters.
  - `tuple_set::Vector{Vector{Int}}`: Set of tuples which arrange the circuit layers.
  - `tuple_set_data::TupleSetData`: [`TupleSetData](@ref) object that generates the tuple set.
  - `shot_weights::Vector{Float64}`: Shot weights for each tuple in the set, which add to 1.
  - `ls_type::Symbol`: Type of least squares estimator for which the scaling is calculated.
"""
abstract type AbstractScalingData end

export AbstractNoiseParameters,
    AbstractCircuitParameters, AbstractCircuit, AbstractScalingData

# Struct exports
export
    # kwargs.jl
    OptimOptions,
    # tableau.jl structs 
    Tableau,
    Gate,
    Layer,
    # noise.jl structs
    DepolarisingParameters,
    LognormalParameters,
    # circuit.jl structs
    Circuit,
    RotatedPlanarParameters,
    RotatedPlanarCircuit,
    UnrotatedPlanarParameters,
    UnrotatedPlanarCircuit,
    # tuples.jl structs
    TupleSetData,
    # design.jl structs
    Pauli,
    Mapping,
    Design,
    # merit.jl structs
    Merit,
    # scaling.jl structs
    DepolarisingPlanarScaling,
    LognormalPlanarScaling,
    # simulate.jl structs
    ACESData

# Function exports
export
    # tableau.jl functions
    apply!,
    make_layer,
    pad_layer,
    # noise.jl functions
    get_dep_param,
    get_log_param,
    # circuit.jl functions
    prepare_circuit,
    get_rotated_param,
    get_unrotated_param,
    get_circuit,
    # tuples.jl functions
    get_basic_tuple_set,
    get_tuple_set_data,
    get_tuple_set,
    # design.jl functions
    generate_design,
    complete_design,
    update_noise,
    # merit.jl functions
    calc_covariance_log,
    calc_gls_moments,
    calc_wls_moments,
    calc_ols_moments,
    calc_ls_moments,
    calc_gls_merit,
    calc_wls_merit,
    calc_ols_merit,
    calc_ls_merit,
    calc_merit_set,
    nrmse_pdf,
    # weights.jl functions
    gls_optimise_weights,
    wls_optimise_weights,
    ols_optimise_weights,
    optimise_weights,
    compare_ls_optimise_weights,
    # optimise.jl functions
    optimise_repetitions,
    optimise_tuple_set,
    optimise_design,
    # scaling.jl functions
    calc_depolarising_planar_scaling,
    calc_lognormal_planar_scaling,
    # simulate.jl functions
    simulate_aces,
    # utils.jl functions
    pretty_print,
    get_pauli_string,
    get_mapping_string,
    # io.jl functions
    enter_folder,
    exit_folder,
    design_filename,
    scaling_filename,
    aces_data_filename,
    save_design,
    load_design,
    delete_design,
    save_scaling,
    load_scaling,
    delete_scaling,
    save_aces,
    load_aces,
    delete_aces

# Include files
include("kwargs.jl")
include("tableau.jl")
include("noise.jl")
include("circuit.jl")
include("tuples.jl")
include("design.jl")
include("merit.jl")
include("weights.jl")
include("optimise.jl")
include("scaling.jl")
include("simulate.jl")
include("utils.jl")
include("io.jl")

# IntelliSence for Julia VSCode does not work, but this hacky trick fixes that
# It convinces the LSP that the following files are part of src
# Source: https://discourse.julialang.org/t/lsp-missing-reference-woes/98231/16
@static if false
    include("../test/runtests.jl")
    include("../test/aqua_tests.jl")
    include("../test/merit_tests.jl")
    include("../test/design_tests.jl")
    include("../scalable_aces/rot_optimise.jl")
    include("../scalable_aces/rot_scaling.jl")
    include("../scalable_aces/rot_simulate.jl")
    include("../scalable_aces/rot_simulate_big.jl")
    include("../scalable_aces/unrot_optimise.jl")
    include("../scalable_aces/unrot_scaling.jl")
    include("../scalable_aces/unrot_simulate.jl")
    include("../scalable_aces/unrot_simulate_big.jl")
end

end
